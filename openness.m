% openness
% Calculates positive openness, a measure the dominance or enclosure of a 
% location on an irregular surface (Yokoyama, Shirasawa, and Pike, 2002). 
% For negative openness, submit -Z rather than Z.
%
% Syntax
%
% [opn opnDist] = openness(Z,cellSize,lookupDistance)
%
% Where opn is a measure of openness (in degrees)
% and opnDist is a measure of average distance (in map units) to the 
% 8 pixels containing the minimum angle.  Warning: opnDist is still in
% experimental stage!
%
%
% From the abstract:
% A new parameter, here termed openness, expressing the degree
% of dominance or enclosure of a location on an irregular
% surface, is developed to visualize topographic character.
% Openness is an angular measure of the relation between
% surface relief and horizontal distance. For angles less than 90",
% it is equivalent to the internal angle of a cone, its apex at a
% DEM location, constrained by neighboring elevations within a
% specified radial distance. Openness incorporates the terrain
% line-of-sight, or viewshed, concept and is calculated from
% multiple zenith and nadir angles-here along eight azimuths.
% Openness has two viewer perspectives. Positive values,
% expressing openness above the surface, are high for convex
% forms, whereas negative values describe this attribute below
% the surface and are high for concave forms. Openness values
% are mapped by gray-scale tones. The emphasis of terrain
% convexity and concavity in openness maps facilitates the
% interpretation of landforms on the Earth's surface and its
% seafloor, and on the planets, as well as features on any
% irregular surface-such as those generated by industrial
% procedures.

% This algorithm works by creating 3D array of size(Z) by 8 (since
% there are eight neighbors).  The minimum angle (defined by the angle
% to the pixel and a line moving straight up from the "observer") is
% retained for each direction.  In this way, a higher neighboring point
% produces a smaller view angle for that direction.  The mean of the
% array reports openness.
%
% The edge handling for this algorithm is not particularly robust

function [opn, opnDist] = openness(Z,cellSize,lookupDist)

    % Neighbor directions are clockwise from upper-left.
    neighbors = 1:8;

    % There is one copy of each neighbor (1-8).
    opn = repmat(Inf*ones(size(Z)),[1 1 length(neighbors)]);
    
    % If the distance to the minimum angle is requested
    opnDistRequested = false;
    if nargout>1
        opnDist = nan(size(opn));
        opnDistRequested = true;
    end
    
    % Open

    % Create a small distance vector to weight diagonal distances correctly.
    dlist = [1 sqrt(2)];

    % For each neighbor direction and lookup distance look for the maximum
    % and minimum angle corresponding to negative and positive openness
    for i = 1:lookupDist
        for j=1:length(neighbors)
            % Calculate the shifted distances in map distance
            dist = cellSize * i * dlist(mod(neighbors(j),2)+1);

            % Calculate the angle to these pixels
            thisAngle = 90-atand((ashift(Z,neighbors(j),i)-Z)./dist);

            % Find where the new angles are less than the old angles.
            % This requires a "reindexing" by factoring in what layer
            % of the openness "answer" matrix I'm looking at.
            whereSmaller = find(thisAngle < opn(:,:,j));
            
            % Wherever those smaller values occurred, write in the new
            % minimum to the answer array
            opn(whereSmaller + (j-1)*numel(Z)) = thisAngle(whereSmaller);
            if opnDistRequested
                opnDist(whereSmaller + (j-1)*numel(Z)) = dist;
            end
            
        end
    end

    % Openness is defined as the mean of the 8 neighbors
%     opn(opn==Inf) = NaN;
    opn = mean(opn,3);
    if opnDistRequested
        opnDist = nanmean(opnDist,3);
    end
    
end

%%
% This function pastes part of an array along a specified direction and 
% number of pixels.  Directions clockwise from top-left (1) to left (8). 
function [M] = ashift(M,dir,n) 
    if nargin<3
        n = 1;
    end

    switch dir
        case 1 
            M(1+n:end,1+n:end) = M(1:end-n,1:end-n);
        case 2
            M(1+n:end,:) = M(1:end-n,:);
        case 3
            M(1+n:end,1:end-n) = M(1:end-n,1+n:end);
        case 4
            M(:,1:end-n) = M(:,1+n:end);
        case 5
            M(1:end-n,1:end-n) = M(1+n:end,1+n:end);
        case 6
            M(1:end-n,:) = M(1+n:end,:);
        case 7
            M(1:end-n,1+n:end) = M(1+n:end,1:end-n);
        case 8
            M(:,1+n:end) = M(:,1:end-n);
    end
end

